package golang

var mainGoTemplate = `// Code generated by Neva. DO NOT EDIT.
package main

import (
    "context"

    "github.com/nevalang/neva/internal/runtime"
    "github.com/nevalang/neva/internal/runtime/funcs"
)

func main() {
    // runtime
    connector := runtime.NewDefaultConnector()
	funcRunner := runtime.MustNewFuncRunner(funcs.CreatorRegistry())
	runTime := runtime.New(connector, funcRunner)

    // ports
    {{- range $idx, $info := .Ports}}
    {{getPortChanName $info.PortAddr}} := make(chan runtime.Msg, {{$info.BufSize}})
    {{- end}}

	// program
    prog := runtime.Program{
        Ports: map[runtime.PortAddr]chan runtime.Msg{
            {{- range $idx, $info := .Ports}}
            {
                Path: "{{$info.PortAddr.Path}}",
                Port: "{{$info.PortAddr.Port}}",
                Idx: {{$info.PortAddr.Idx}},
            }: {{getPortChanName $info.PortAddr}},
            {{- end}}
        },
        Connections: []runtime.Connection{
            {{- range $sender, $receivers := .Connections}}
            {{ getConnComment $sender, $receivers }}
            {
                Sender: {{getPortChanName .SenderSide}},
                Receivers: []chan runtime.Msg{
                {{- range .ReceiverSides }}
                    {{getPortChanName .PortAddr}},
                {{- end}}
                },
                Meta: runtime.ConnectionMeta{
                    SenderPortAddr: runtime.PortAddr{
                        Path: "{{.SenderSide.Path}}",
                        Port: "{{.SenderSide.Port}}",
                        Idx: {{.SenderSide.Idx}},
                    },
                    ReceiverPortAddrs: []runtime.PortAddr{
                    {{- range .ReceiverSides }}
                        {
                            Path: "{{.PortAddr.Path}}",
                            Port: "{{.PortAddr.Port}}",
                            Idx: {{.PortAddr.Idx}},
                        },
                    {{- end}}
                    },
                },
            },
            {{- end}}
        },
        Funcs: []runtime.FuncCall{
            {{- range .Funcs}}
            {
                Ref: "{{.Ref}}",
                IO: runtime.FuncIO{
                    In: map[string][]chan runtime.Msg{
                        {{getFuncIOPorts .IO.In}}
                    },
                    Out: map[string][]chan runtime.Msg{
                        {{getFuncIOPorts .IO.Out}}
                    },
                },
                ConfigMsg: {{getMsg .Msg}},
            },
            {{- end}}
        },
    }
    
    if err := runTime.Run(context.Background(), prog); err != nil {
        panic(err)
    }
}`

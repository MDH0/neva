// basic stream operations

// Wait blocks until last stream item arrive, then sends signal.
pub flow Wait(data stream<any>) (sig) {
    nodes { If }
    :data.last -> if
    if:then -> :sig
}

// Range sends sequence of integers starting and ending with given from and to.
// It supports negative ranges e.g. `-3, 0`. Integers are decremented in that case.
#extern(stream_int_range)
pub flow Range(from int, to int) (data stream<int>)

// StreamPort iterates over all array-inport's slots in order
// and produces a stream of messages.
#extern(array_port_to_stream)
pub flow StreamPort<T>([port] T) (seq stream<T>)

// IPortReducer reduces a stream of messages to one single message.
// It's expected to send a result message after every processed stream.
pub interface IPortReducer<T>(seq stream<T>) (res T)

// ReducePort reduces messages from multiple connections to a single message.
// It iterates over all array-inport's slots in order and streams every message
// to reducer. When all messages are processed the result is emited to outport.
pub flow ReducePort<T>([port] T) (res T) {
    nodes { reducer IPortReducer<T>, streamer StreamPort<T> }
    :port => streamer:port
    streamer -> reducer -> :res
}

// === Iterators ===

// These constants are used for binding by Field flow.
const dataPath list<string> = ['data']
const lastPath list<string> = ['last']
const idxPath list<string> = ['idx']

// --- For ---

// IForHandler is a dependency for For flow.
pub interface IForHandler<T>(data T) (sig any)

// For performs side-effect on stream item. It's for side-effects only.
// If you want to map one stream onto another, use Map instead.
// Just like Map, For does not block the stream. As soon as one item processed,
// it sends it downstream and receives the next one.
// Use Wait to wait for end of the stream.
pub flow For<T>(data stream<T>) (data stream<T>) {
    nodes {
        Lock<stream<T>>
        handler IForHandler<T>

        #bind(dataPath)
        getData Field<T>
    }

    :data -> [getData, lock:data]
    getData -> handler -> lock:sig
    lock -> :data
}

// --- Map ---

// IMapHandler is a dependency for Map flow.
pub interface IMapHandler<T, Y>(data T) (res Y)

// Map maps one stream onto another. It's intented for "pure" mapping,
// but could be combined with side-effects if needed.
// Map does not block the stream. As soon as one item processed:
// it sends it downstream and receives the next one.
pub flow Map<T, Y>(data stream<T>) (res stream<Y>) {
    nodes {
        fanOut FanOut<stream<T>>
        handler IMapHandler<T, Y>
        wrap Struct<stream<Y>>
    }

    :data -> fanOut
    
    fanOut[0].idx -> wrap:idx
    fanOut[1].last -> wrap:last
    fanOut[2].data -> handler -> wrap:data

    wrap -> :res
}
